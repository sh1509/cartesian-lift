# cartesian-lift

This project involves simulating and controlling Cartesian motions of a 6-DOF robotic arm mounted on a vertical prismatic joint (lift) using ROS 2 and Ignition Gazebo. It includes velocity-controlled motion, trajectory generation, and optional compliance control.

---

## Project Phases
The project is divided into several phases, each with specific deliverables and tasks. The phases are outlined in the `TaskManager.md` file, which includes a progress log and extra TODOs.
## Task Management
The project uses a task management system to track progress and deliverables. The `TaskManager.md` file contains a detailed log of tasks, their status, and timestamps. It is structured into phases, with each phase having specific deliverables and tasks to complete. 


## Environment Setup
The environment setup phase involves creating a Dockerfile that includes all necessary dependencies for running ROS 2 and Ignition Gazebo. The Dockerfile is designed to be used with a base image of ROS 2 Humble, and it includes the installation of Gazebo Fortress, URDF model verification, and the setup of the UR10e robot model with a vertical prismatic joint. 

## ROS 2 Packages
The project includes several ROS 2 packages:
* `my_ur10e_custom_description`: Contains the URDF model, launch files, and configuration for the UR10e robot with a vertical prismatic joint.
  - `ur10e_with_prismatic.urdf.xacro`: The modified URDF for the UR10e robot with a vertical lift joint.
  - `controllers.yaml`: Configuration for the robot's controllers.
  - `spawn_ur10e.launch.py`: Launch file to spawn the UR10e robot in Ignition Gazebo.
  - `rviz/ur10e.rviz`: RViz configuration file for visualizing the UR10e robot.
  - `models/wall.sdf`: A simple wall model used in the simulation environment.
  - `wall_marker_publisher.py`: A ROS 2 node to publish a wall marker in the rviz environment.
* `ur10e_ikpy_solver`: Contains the custom inverse kinematics solver and a node for running Cartesian motion with the UR10e robot.
  - `cartesian_motion_runner` is responsible for executing Cartesian motions based on the IK solutions generated by the `ik_solver` module.
  - `ik_solver` contains the `ur10e_kinematics.py` file, which implements the inverse kinematics calculations for the UR10e robot with the added vertical lift joint.
* `external/Universal_Robots_ROS2_Description`: A submodule that provides the UR10e robot description and necessary configurations for ROS 2.

## Project Structure

```
cartesian-lift/
├── docker/
│   ├── Dockerfile
│   ├── docker-compose.sim.yaml
├── ur10e_ikpy_solver/
│   ├── ur10e_ikpy_solver/
│   │   ├── __init__.py
│   │   ├── cartesian_motion_runner.py
│   │   ├── ik_solver/
│   │   │   ├── __init__.py
│   │   │   ├── ur10e_kinematics.py
│   ├── setup.py
├── my_ur10e_custom_description/
│   ├── my_ur10e_custom_description/
│   │   ├── __init__.py
│   │   ├── models/
│   │   │   ├── wall.sdf
│   │   ├── launch/
│   │   │   ├── spawn_ur10e.launch.py
│   │   ├── urdf/
│   │   │   ├── ur10e_with_prismatic.urdf.xacro
│   │   ├── config/
│   │   │   ├── controllers.yaml
│   │   ├── rviz/
│   │   │   ├── ur10e.rviz
├── external/
│   ├── Universal_Robots_ROS2_Description/
├── README.md
└── TaskManager.md
```

## Getting Started

## Prerequisites: Modify the external submodule `Universal_Robots_ROS2_Description`
Modify the external submodule `Universal_Robots_ROS2_Description` to include the UR10e robot model. The project includes a custom URDF for the UR10e with a vertical prismatic joint.

The URDF has been modified to include a vertical prismatic joint for the lift. The following changes were made:
```xml
# urdf/inc/ur_transmissions.xacro
+ <hardwareInterface>${hw_interface}</hardwareInterface>  # For each actuator
+ <transmission name="lift_joint_trans"> ... </transmission> # Add a transmission for the lift joint
```

```xml
# urdf/ur.ros2_control.xacro
<joint name="${tf_prefix}lift_joint">
  <command_interface name="position"/>
  <command_interface name="velocity"/>
  <state_interface name="position">
    <param name="initial_value">0.1</param>
  </state_interface>
  <state_interface name="velocity"/>
  <state_interface name="effort"/>
</joint>
```

```xml
# urdf/ur_macro.xacro
- <!--<xacro:ur_arm_transmission ... />-->
+ <xacro:ur_arm_transmission prefix="" hw_interface="${transmission_hw_interface}"/>

# urdf/ur.ros2_control.xacro
# Add the lift joint to the robot description
<joint name="${tf_prefix}lift_joint">
  <command_interface name="position"/>
  <command_interface name="velocity"/>
  <state_interface name="position">
    <param name="initial_value">0.1</param>
  </state_interface>
  <state_interface name="velocity"/>
  <state_interface name="effort"/>
</joint>
  # Add full lift_joint block
```

```xml
# urdf/ur_macro.xacro
# modify the hw_interface and transmission blocks
+ <xacro:ur_arm_transmission prefix="" hw_interface="${transmission_hw_interface}"/>
```


## How to Use This Project
1. **Clone the repository**:
    ```bash
      git clone https://github.com/sh1509/cartesian-lift.git
    ```
2. **Navigate to the project directory**:
   ```bash
   cd cartesian-lift
   ```
3. **Initialize and update submodules**:
   ```bash
    git submodule update --init --recursive
    ```
4. **Build the Docker image**:

    ```bash
    cd docker
    docker compose -f docker-compose.sim.yaml build
    ```
5. **Run the Docker container**:
    ```bash
    docker compose -f docker-compose.sim.yaml run --rm --name cartesian-lift-sim bash
    ```
6. **Access the ROS 2 environment**:

    ```bash
    docker exec -it cartesian-lift-sim bash
    ```
   Replace `<container_name>` with the name of your running Docker container.
7. **Run the Gazebo simulation and Rviz**:
    ```bash
    $ ros2 launch my_ur10e_custom_description spawn_ur10e.launch.py
    ```
8. **Run the Cartesian motion node**:
    ```bash
    $ ros2 run ur10e_ikpy_solver cartesian_motion_runner
    ```
    


---

### Notes

* Before running the container, run `xhost +local:root` on your host to allow GUI forwarding.
* This setup assumes you are running on a Linux host with X11. For Windows or Mac, additional configuration may be required.

---

## Dependencies

This project depends on the following:

* **Universal\_Robots\_ROS2\_Description**
  Included as a git submodule under the `external/` directory.
  To initialize and update it:

  ```bash
  git submodule update --init --recursive
  ```

* **ROS 2 Humble** with the following packages:

  * `gazebo_ros_pkgs`
  * `gazebo_ros2_control`
  * `ros_ign`
  * `xacro`
  * `rviz2`
  * `joint_state_publisher_gui`
  * `robot_state_publisher`
  * `ros2_control`
  * `ros2_controllers`

* **Python packages**:

  * `ikpy` (for inverse kinematics) (installed but not used in the current implementation)
  * `numpy`
  * `scipy`
  * `matplotlib` (for plotting)

* **Gazebo Fortress (Ignition Gazebo)**
  Installed via OSRF APT repository:

  ```Dockerfile
  curl https://packages.osrfoundation.org/gazebo.gpg --output /usr/share/keyrings/pkgs-osrf-archive-keyring.gpg
  echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/pkgs-osrf-archive-keyring.gpg] http://packages.osrfoundation.org/gazebo/ubuntu-stable $(lsb_release -cs) main" > /etc/apt/sources.list.d/gazebo-stable.list
  apt-get update && apt-get install -y ignition-fortress
  ```

> All dependencies are installed in the provided Dockerfile.

---

